// Name: Alay Dilipbhai Shah
// USC NetID: 4038-9488-19
// CS 455 PA4
// Spring 2019


// Importing necessary packages:
import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;
import java.util.TreeMap;


/**
 * Score Generator Class integrates the functionality of all the other classes (Rack, AnagramDictionary, ScoreTable) to compute
 * all the possible wordFormations and their scores for the word currently on rack.
 * @author Alay
 */

public class ScoreGenerator
{
	//Private Instance Variables
	private Rack rack;								//Instance for Rack Class
	private AnagramDictionary dictionary;			//Instance for AnagramDictionary Class 
	private ScoreTable scoreTable;					//Instance for ScoreTable class
	private String wordOnRack;						//Instance for storing the word currently present on the rack.
	
	
	// # Representation Invariants for this class:
	// Since this class just integrates the functionality of all the other above mentioned classes,
	// hence this class doesn't have any representation invariant of its own. 
	// It just inherits the representation variants of other classes that is integrates.
	
	/**
	 * Initiates all the above instance variables using the below mentioned input parameters  
	 * @param s the word currently on rack
	 * @param dict the AnagramDictionary to be used i.e. the default one or the one mentioned explicitly by the user.
	 */
	
	public ScoreGenerator(String s, AnagramDictionary dict) {
		wordOnRack = s;
		dictionary = dict;
		rack = new Rack(wordOnRack);
		scoreTable = new ScoreTable();
	}
	
	
	/**
	 * This function computes all the possible legal(present in the dictionary) wordFormations, 
	 * and their respective scores for the word currently present on the rack.
	 * 
	 * @return A TreeMap in reverse decreasing order of its keys i.e. integers, 
	 * where integer key is the score of word and the value of each key-integer(score) 
	 * is the array list of all the possible word formations having the same scores as the key-score.
	 */
	
	private Map<Integer, ArrayList<String>> getAllScores(){
		
		Map<Integer, ArrayList<String>> scoresMap = new TreeMap<Integer, ArrayList<String>>(Collections.reverseOrder());
		
		// First each subset generated by the rack.getSubsets() method for the word currently on rack, first get the score of the subset from the score
		// table and get all the anagrams in the form of array list of that subset with the help of getAnagrams method, and then map the score key with
		// its respective list of Anagram words which will be having the same scores on the scoresMap.
		for (String subset: rack.getSubsets()) {
			int score = scoreTable.getWordScore(subset);
			ArrayList<String> value = dictionary.getAnagramsOf(subset);

			// If the score is already present in the scoresMap, then get the old list of words, 
			// and merge it with the new list of words generated from another subset. 
			// Else, just map the score key with its corresponding array list value of words.
			if (scoresMap.containsKey(score)) {	
				ArrayList<String> oldVal = scoresMap.get(score);
				value.addAll(oldVal);	
			}
			
			// Before mapping, the array list, which is the value for any particular score key, is sorted in alphabetic order
			// so that we can print all the words having same scores in alphabetic order later while printing out scoresMap.
			Collections.sort(value); 
			scoresMap.put(score, value);	
		}
		return scoresMap;
	}

	
	/**
	 * Prints some necessary informative messages along with the scores in a specific format with i.e. "score : word" by traversing the tree-map in the regular order. 
	 * NOTE: The tree map is already sorted in reverse order of its keys(scores), hence naturally the higher scores will be printed first. 
	 * Also, only one word will be printed per line. Hence all the words having the same scores will be printed in alphabetically order.
	 */
	
	public void printScores() {
		Map<Integer, ArrayList<String>> sortedScores = getAllScores();
		String output = "";
		int wordsMade = 0;
		
		for (Map.Entry<Integer, ArrayList<String>> entry : sortedScores.entrySet()) {
			if (entry.getValue().size() != 0) {
				for (String element : entry.getValue()) {
					output += entry.getKey() + ": " + element + "\n";
					wordsMade++;
				}	
			}
		}
		
		System.out.println("We can make " + wordsMade + " words from " + "\"" + wordOnRack + "\"");
		
		if (wordsMade > 0) {
			System.out.println("All of the words with their scores (sorted by score):");
			System.out.print(output);
		}		
	}
}
